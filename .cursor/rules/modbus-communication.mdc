---
description: Modbus Communication Patterns
globs: ["src/modbus_manager.py", "src/dpt_9001.py", "src/const.py"]
alwaysApply: false
---

# Modbus Communication Patterns

## Circuit Breaker Implementation

- Implement circuit breaker pattern for fault tolerance
- Use three states: CLOSED (normal), OPEN (failing), HALF-OPEN (testing)
- Track failure counts and timeouts
- Provide fallback mechanisms when circuit is open

```python
class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout=60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = 'CLOSED'
```

## Context Management

- Use proper context managers for Modbus connections
- Ensure connections are properly closed even on exceptions
- Implement connection pooling for multiple operations
- Handle connection timeouts gracefully

```python
@contextmanager
def modbus_context():
    try:
        client = ModbusTcpClient(host, port)
        client.connect()
        yield client
    finally:
        client.close()
```

## Error Handling

- Catch specific Modbus exceptions (ModbusException, ConnectionException)
- Implement retry logic with exponential backoff
- Log all Modbus communication errors
- Provide meaningful error messages for debugging
- Use fallback values when Modbus communication fails

## Data Type Handling

- Use proper DPT (Data Point Type) conversions
- Handle different Modbus data types (holding registers, input registers)
- Implement proper byte ordering (big-endian, little-endian)
- Validate data ranges and types before processing

## Caching Strategy

- Cache frequently accessed values to reduce Modbus traffic
- Implement cache invalidation based on time or change detection
- Use in-memory cache as fallback when database is unavailable
- Store cache metadata (timestamp, validity)

## Batch Operations

- Group multiple Modbus operations into single requests
- Use read_multiple_registers for bulk data retrieval
- Implement efficient write operations for multiple values
- Handle partial failures in batch operations

## Connection Management

- Implement connection health checks
- Use connection pooling for concurrent operations
- Handle network timeouts and reconnections
- Monitor connection status and log metrics

## Data Validation

- Validate Modbus register addresses before reading/writing
- Check data ranges and types
- Implement data integrity checks
- Handle corrupted or invalid data gracefully

## Logging and Monitoring

- Log all Modbus operations with timestamps
- Monitor communication success/failure rates
- Track response times and performance metrics
- Log circuit breaker state changes
- Implement health check endpoints for Modbus status

## Thread Safety

- Use thread-safe operations for concurrent access
- Implement proper locking mechanisms
- Handle race conditions in shared resources
- Use thread-local storage where appropriate

## Configuration

- Use configuration files for Modbus settings
- Support different connection types (TCP, Serial)
- Implement flexible slave ID configuration
- Allow runtime configuration changes