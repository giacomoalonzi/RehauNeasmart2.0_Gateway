---
description: Database & Persistence Patterns
globs: ["src/database.py", "src/config.py", "*.db"]
alwaysApply: false
---

# Database & Persistence Patterns

## SQLite Database Management

- Use SQLite for local data persistence
- Implement connection pooling for concurrent access
- Use proper transaction management
- Handle database locking and concurrency issues

```python
import sqlite3
from contextlib import contextmanager
from threading import Lock

class DatabaseManager:
    def __init__(self, db_path):
        self.db_path = db_path
        self.lock = Lock()
    
    @contextmanager
    def get_connection(self):
        conn = sqlite3.connect(self.db_path, timeout=30.0)
        try:
            yield conn
        finally:
            conn.close()
```

## Fallback Mechanisms

- Implement in-memory fallback when database is unavailable
- Use cached values when primary storage fails
- Provide graceful degradation of functionality
- Log all fallback activations for monitoring

```python
class FallbackStorage:
    def __init__(self):
        self.cache = {}
        self.last_update = {}
    
    def get_cached_value(self, key, max_age=300):
        if key in self.cache:
            age = time.time() - self.last_update.get(key, 0)
            if age < max_age:
                return self.cache[key]
        return None
```

## Data Schema Management

- Use proper database schema versioning
- Implement migration scripts for schema changes
- Validate data integrity on startup
- Use appropriate data types and constraints

```python
def initialize_database(db_path):
    with sqlite3.connect(db_path) as conn:
        conn.execute('''
            CREATE TABLE IF NOT EXISTS temperature_data (
                zone_id INTEGER PRIMARY KEY,
                temperature REAL NOT NULL,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        conn.execute('''
            CREATE TABLE IF NOT EXISTS system_status (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        ''')
```

## Connection Management

- Use context managers for database connections
- Implement proper connection cleanup
- Handle connection timeouts and retries
- Monitor connection health

```python
@contextmanager
def database_connection(db_path, timeout=30.0):
    conn = None
    try:
        conn = sqlite3.connect(db_path, timeout=timeout)
        conn.execute("PRAGMA journal_mode=WAL")
        yield conn
    except sqlite3.OperationalError as e:
        logger.error(f"Database error: {e}")
        raise
    finally:
        if conn:
            conn.close()
```

## Data Persistence Patterns

- Store frequently accessed data in database
- Implement efficient data retrieval
- Use appropriate indexing for performance
- Handle data serialization and deserialization

```python
def store_temperature_data(zone_id, temperature, timestamp=None):
    if timestamp is None:
        timestamp = datetime.now()
    
    with database_connection(DB_PATH) as conn:
        conn.execute('''
            INSERT OR REPLACE INTO temperature_data 
            (zone_id, temperature, timestamp)
            VALUES (?, ?, ?)
        ''', (zone_id, temperature, timestamp))
        conn.commit()
```

## Error Handling

- Handle database connection errors gracefully
- Implement retry logic for transient failures
- Log all database operations and errors
- Provide meaningful error messages

```python
def safe_database_operation(operation, *args, **kwargs):
    max_retries = 3
    for attempt in range(max_retries):
        try:
            return operation(*args, **kwargs)
        except sqlite3.OperationalError as e:
            if attempt == max_retries - 1:
                logger.error(f"Database operation failed after {max_retries} attempts: {e}")
                raise
            time.sleep(2 ** attempt)  # Exponential backoff
```

## Performance Optimization

- Use prepared statements for repeated queries
- Implement proper indexing strategy
- Use WAL mode for better concurrency
- Monitor query performance

```python
def get_temperature_history(zone_id, limit=100):
    with database_connection(DB_PATH) as conn:
        cursor = conn.execute('''
            SELECT temperature, timestamp 
            FROM temperature_data 
            WHERE zone_id = ? 
            ORDER BY timestamp DESC 
            LIMIT ?
        ''', (zone_id, limit))
        return cursor.fetchall()
```

## Data Validation

- Validate data before storing in database
- Use proper data types and constraints
- Implement data integrity checks
- Handle invalid data gracefully

```python
def validate_temperature_data(temperature):
    if not isinstance(temperature, (int, float)):
        raise ValueError("Temperature must be a number")
    if temperature < -50 or temperature > 100:
        raise ValueError("Temperature out of valid range")
    return float(temperature)
```

## Backup and Recovery

- Implement database backup strategies
- Handle database corruption scenarios
- Provide data recovery mechanisms
- Monitor database health

```python
def backup_database(source_path, backup_path):
    try:
        shutil.copy2(source_path, backup_path)
        logger.info(f"Database backed up to {backup_path}")
    except Exception as e:
        logger.error(f"Backup failed: {e}")
        raise
```

## Monitoring and Logging

- Log all database operations
- Monitor database performance metrics
- Track connection usage and errors
- Implement health check endpoints

```python
def log_database_operation(operation, duration, success=True):
    logger.info(f"Database operation: {operation}, duration: {duration}ms, success: {success}")
    if not success:
        logger.error(f"Database operation failed: {operation}")
```