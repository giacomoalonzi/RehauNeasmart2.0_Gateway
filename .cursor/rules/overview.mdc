---
description: Rehau Neasmart 2.0 Gateway - Rules Overview
globs:
alwaysApply: true
---

# Rehau Neasmart 2.0 Gateway - Rules Overview

This project uses **nested Cursor rules** organized by domain for better maintainability and context-specific guidance:

## 🏗️ Project Structure Rules

- **Location**: `.cursor/rules/project-structure.mdc`
- **Scope**: Python backend architecture, Flask API, Modbus communication
- **Auto-applied to**: Configuration files (`*.json`, `*.py`, `requirements.txt`)

## 🔌 Modbus Communication Rules

- **Location**: `.cursor/rules/modbus-communication.mdc`
- **Scope**: Modbus protocol, circuit breaker patterns, error handling
- **Auto-applied to**: Modbus-related files (`modbus_manager.py`, `dpt_9001.py`)

## 🌐 API Development Rules

- **Location**: `.cursor/rules/api-development.mdc`
- **Scope**: Flask blueprints, REST endpoints, request/response patterns
- **Auto-applied to**: API files in `src/api/` directory

## 🗄️ Database & Persistence Rules

- **Location**: `.cursor/rules/database-patterns.mdc`
- **Scope**: SQLite operations, data persistence, fallback mechanisms
- **Auto-applied to**: Database-related files (`database.py`, `*.db`)

## 🧪 Testing & Quality Rules

- **Location**: `.cursor/rules/testing-patterns.mdc`
- **Scope**: pytest patterns, integration tests, mock strategies
- **Auto-applied to**: Test files in `tests/` directory

## 📚 Documentation Rules

- **Location**: `.cursor/rules/documentation-patterns.mdc`
- **Scope**: API documentation, code comments, README patterns
- **Auto-applied to**: Documentation files (`docs/`, `*.md`)

## How Nested Rules Work

According to @Cursor's nested rules documentation:

- Rules are **automatically attached** when working with files in their respective directories
- They provide **domain-specific guidance** without cluttering the global context
- Perfect for **backend services** with distinct components that need specific guidance
- All rules remain **available in the context picker** for manual inclusion

This structure ensures you get the right guidance at the right time, whether you're:

- 🔌 Working on Modbus communication protocols
- 🌐 Building REST API endpoints
- 🗄️ Managing data persistence and caching
- 🧪 Writing tests for hardware integration
- 📚 Documenting API and system architecture

# Commit Guidelines

Follow these rules when writing commit messages.  
The format is based on [Conventional Commits](https://www.conventionalcommits.org/).

---

## ✅ Commit Message Format

- **type** → the kind of change (feat, fix, chore, etc.)
- **scope** → optional, the part of the codebase affected (auth, ui, api, etc.)
- **short description** → imperative present tense, concise, no period at the end

### Examples

- `feat(auth): add token validation`
- `fix(ui): correct login button behavior`
- `docs(readme): update installation section`

---

## 🎯 Allowed Commit Types

- **feat** → a new feature
- **fix** → a bug fix
- **refactor** → code change that neither fixes a bug nor adds a feature
- **docs** → documentation only changes
- **test** → adding or adjusting tests
- **style** → formatting, linting, or style changes (no code logic)
- **chore** → maintenance tasks (build, config, dependencies)
- **perf** → performance improvements

---

## 📝 Short Description Rules

- Use **imperative present tense**: “add” not “added” or “adds”
- Keep it under **60 characters**
- **Do not** end with a period

---

## 📄 Extended Description (Optional)

If more detail is needed:

1. Leave one blank line after the header
2. Explain **what** changed and **why**
3. Reference issues when relevant:

---

## 📌 General Rules

- Each commit should be **atomic** → one logical change per commit
- Avoid vague messages like “fix stuff” or “update code”
- If multiple scopes are affected, prefer splitting into multiple commits

---
