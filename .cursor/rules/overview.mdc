---
description: Rehau Neasmart 2.0 Gateway - Rules Overview
globs:
alwaysApply: true
---

# Rehau Neasmart 2.0 Gateway - Rules Overview

This project uses **nested Cursor rules** organized by domain for better maintainability and context-specific guidance:

## ğŸ—ï¸ Project Structure Rules

- **Location**: `.cursor/rules/project-structure.mdc`
- **Scope**: Python backend architecture, Flask API, Modbus communication
- **Auto-applied to**: Configuration files (`*.json`, `*.py`, `requirements.txt`)

## ğŸ”Œ Modbus Communication Rules

- **Location**: `.cursor/rules/modbus-communication.mdc`
- **Scope**: Modbus protocol, circuit breaker patterns, error handling
- **Auto-applied to**: Modbus-related files (`modbus_manager.py`, `dpt_9001.py`)

## ğŸŒ API Development Rules

- **Location**: `.cursor/rules/api-development.mdc`
- **Scope**: Flask blueprints, REST endpoints, request/response patterns
- **Auto-applied to**: API files in `src/api/` directory

## ğŸ—„ï¸ Database & Persistence Rules

- **Location**: `.cursor/rules/database-patterns.mdc`
- **Scope**: SQLite operations, data persistence, fallback mechanisms
- **Auto-applied to**: Database-related files (`database.py`, `*.db`)

## ğŸ§ª Testing & Quality Rules

- **Location**: `.cursor/rules/testing-patterns.mdc`
- **Scope**: pytest patterns, integration tests, mock strategies
- **Auto-applied to**: Test files in `tests/` directory

## ğŸ“š Documentation Rules

- **Location**: `.cursor/rules/documentation-patterns.mdc`
- **Scope**: API documentation, code comments, README patterns
- **Auto-applied to**: Documentation files (`docs/`, `*.md`)

## How Nested Rules Work

According to @Cursor's nested rules documentation:

- Rules are **automatically attached** when working with files in their respective directories
- They provide **domain-specific guidance** without cluttering the global context
- Perfect for **backend services** with distinct components that need specific guidance
- All rules remain **available in the context picker** for manual inclusion

This structure ensures you get the right guidance at the right time, whether you're:

- ğŸ”Œ Working on Modbus communication protocols
- ğŸŒ Building REST API endpoints
- ğŸ—„ï¸ Managing data persistence and caching
- ğŸ§ª Writing tests for hardware integration
- ğŸ“š Documenting API and system architecture

# Commit Guidelines

Follow these rules when writing commit messages.  
The format is based on [Conventional Commits](https://www.conventionalcommits.org/).

---

## âœ… Commit Message Format

- **type** â†’ the kind of change (feat, fix, chore, etc.)
- **scope** â†’ optional, the part of the codebase affected (auth, ui, api, etc.)
- **short description** â†’ imperative present tense, concise, no period at the end

### Examples

- `feat(auth): add token validation`
- `fix(ui): correct login button behavior`
- `docs(readme): update installation section`

---

## ğŸ¯ Allowed Commit Types

- **feat** â†’ a new feature
- **fix** â†’ a bug fix
- **refactor** â†’ code change that neither fixes a bug nor adds a feature
- **docs** â†’ documentation only changes
- **test** â†’ adding or adjusting tests
- **style** â†’ formatting, linting, or style changes (no code logic)
- **chore** â†’ maintenance tasks (build, config, dependencies)
- **perf** â†’ performance improvements

---

## ğŸ“ Short Description Rules

- Use **imperative present tense**: â€œaddâ€ not â€œaddedâ€ or â€œaddsâ€
- Keep it under **60 characters**
- **Do not** end with a period

---

## ğŸ“„ Extended Description (Optional)

If more detail is needed:

1. Leave one blank line after the header
2. Explain **what** changed and **why**
3. Reference issues when relevant:

---

## ğŸ“Œ General Rules

- Each commit should be **atomic** â†’ one logical change per commit
- Avoid vague messages like â€œfix stuffâ€ or â€œupdate codeâ€
- If multiple scopes are affected, prefer splitting into multiple commits

---
