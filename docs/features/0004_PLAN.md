# Feature Plan: Versioned Human-Readable Operation APIs

Introduce versioned REST endpoints that return and accept "parlanti" string literals (e.g. `"auto"`, `"normal"`) instead of raw integers for global operation mode/state, while keeping existing numeric endpoints for backward compatibility. New responses must follow the shapes already documented in `API_DOCS.md`, and requests must transparently convert human-readable values back to integers for the Modbus layer and database.

## Scope & Impacted Files
- `src/api/__init__.py`: register versioned blueprints under `/api/v1` (legacy) and `/api/v2` (human-readable).
- `src/api/operation.py`: split legacy handlers and add v2 handlers that expose string values, reuse shared logic.
- `src/api/zones.py`: plan future-proof response structure alignment with `API_DOCS.md` (string states) to maintain consistency once v2 is extended to zones.
- `src/models/operation_models.py`: extend models to accept both integers and strings, add validation hooks.
- `src/services/operation_service.py` (new): encapsulate read/write logic with mapping to keep endpoints thin.
- `src/utils/state_converter.py` (new): centralize integer ↔ string conversion using `const.MODE_MAPPING` and `const.STATE_MAPPING` with validation errors.
- `src/utils/data_transformer.py`: expose helpers for selective field renaming to satisfy snake_case ↔ camelCase conversions.
- `API_DOCS.md`: document `/api/v2/operation/mode` and `/api/v2/operation/state` payloads and clarify legacy `/api/v1` numeric behavior.
- `tests/integration/test_operation_endpoints.py`, `tests/unit/test_state_converter.py` (new): ensure conversions and HTTP flows work.

## Phase 1 — Conversion Utilities & Models
1. Add `src/utils/state_converter.py` with functions:
   - `mode_to_name(mode: int) -> str`
   - `name_to_mode(name: str) -> int`
   - `state_to_name(state: int) -> str`
   - `name_to_state(name: str) -> int`
   Each must raise descriptive `ValueError` when mapping fails and use canonical keys from `const.MODE_MAPPING` / `const.STATE_MAPPING`. Maintain snake_case inputs/outputs internally; only camelCase should be exposed after `data_transformer` processing.
2. Update `src/models/operation_models.py` so `OperationMode` and `OperationState` accept Union[int, str] on instantiation, normalize to integers for persistence, and expose helper methods (e.g. `as_dict(readable: bool) -> dict`). Preserve validation without allowing zero or out-of-range values.
3. Enhance `src/utils/data_transformer.py` with a lightweight API that lets endpoints request camelCase conversion only for specific keys (e.g. `{'mode': 'mode'}` while leaving already user-friendly string values untouched). Document how backend snake_case is transformed to frontend camelCase and vice versa.

## Phase 2 — API Versioning Infrastructure
1. Restructure `src/api/__init__.py` into sub-blueprints:
   - Keep existing routes under a legacy blueprint registered at `/api/v1` to avoid breaking current clients.
   - Introduce a new blueprint namespace `/api/v2` that will host human-readable endpoints.
2. Adjust factory/registration logic to mount both versions while reusing shared services.
3. Ensure default `/api` redirects or references `/api/v1` to maintain current behavior until clients migrate.

## Phase 3 — Operation Mode & State v2 Endpoints
1. Refactor `src/api/operation.py`:
   - Extract shared read/write helpers that interact with Modbus context via an `OperationService` class (new file in `src/services/operation_service.py`).
   - Maintain existing handlers for `/api/v1/operation/mode` and `/api/v1/operation/state` returning integers.
   - Add `/api/v2/operation/mode` and `/api/v2/operation/state` handlers that:
     - On GET: call service to fetch integer values, convert to readable strings using `state_converter`, wrap in dictionaries matching `API_DOCS.md`, then pass through camelCase transformation (`mode` → `mode`, `state` → `state`).
     - On POST: accept payloads with either readable strings (`"heating"`, `"normal"`) or integers, normalize via `state_converter`, validate, write to Modbus, and return confirmation payloads echoing the readable string.
   - Add consistent error responses with clear messages when conversion fails.
2. Implement `src/services/operation_service.py` to encapsulate:
   - Fetching current mode/state from Modbus context.
   - Writing validated values back to context.
   - Logging and exception handling so endpoints can remain concise.

## Phase 4 — Extended Alignment & Documentation
1. Prepare `src/api/zones.py` and `src/services/zone_service.py` for future v2 expansion by documenting required adjustments (e.g. return `"state": "presence"` as in `API_DOCS.md` and accept readable states). While implementation can follow later, outline data structures to keep plan coherent.
2. Update `API_DOCS.md` with new `/api/v2` endpoints, specifying readable request/response samples, mention that backend stores integers, and clarify migrations paths from `/api/v1`.
3. Ensure data naming conventions are explicit: backend uses snake_case, frontend uses camelCase (e.g. `operation_mode` ↔ `operationMode`, `operation_state` ↔ `operationState`).

## Phase 5 — Testing Strategy
1. Create `tests/unit/test_state_converter.py` covering success/failure cases for all mapping utilities.
2. Add `tests/integration/test_operation_endpoints.py`:
   - Test GET `/api/v2/operation/mode` returns `{"mode": "auto"}` when register contains integer `1`.
   - Test POST `/api/v2/operation/state` accepts both `{"state": "normal"}` and `{"state": 1}`; verify payload conversion to Modbus writes (mock context) and 202/200 responses.
   - Confirm `/api/v1` endpoints keep numeric payloads untouched.
3. Extend or create fixtures for mocked Modbus context so tests remain deterministic.

## Algorithms
- **GET `/api/v2/operation/mode` Flow**:
  1. Flask handler resolves `OperationService` from app config.
  2. Service reads integer register value from Modbus context.
  3. Handler converts integer to readable string via `state_converter.mode_to_name`.
  4. Response dict `{"mode": readable}` is passed through `transform_api_response(..., to_camel=True)` to produce camelCase keys.
  5. JSON response returned with HTTP 200.

- **POST `/api/v2/operation/state` Flow**:
  1. Handler parses JSON payload; `apply_field_mappings(..., reverse=True)` converts camelCase keys to snake_case.
  2. If `state` is a string, normalize with `name_to_state`; if integer, validate range.
  3. Service writes integer value to Modbus context and returns success flag.
  4. Handler replies with payload echoing readable string, transformed to camelCase.

## Data Transformation Requirements
- Requests: convert camelCase keys (e.g. `state`, `mode`) to snake_case before validation; readable strings are converted to integers via `state_converter`.
- Responses: expose camelCase keys using `transform_api_response` while keeping readable strings as-is (no extra transformation to snake_case after conversion).
- Ensure new helpers respect existing mappings in `src/utils/data_transformer.py` to avoid duplicating conversion logic.

## TODO Checklist

- [x] Phase 1 — Conversion Utilities & Models
  - [x] Create `src/utils/state_converter.py` with bidirectional mode/state mapping helpers
  - [x] Update `src/models/operation_models.py` to accept strings and normalize to integers
  - [x] Enhance `src/utils/data_transformer.py` for selective key conversion between snake_case and camelCase
- [x] Phase 2 — API Versioning Infrastructure
  - [x] Refactor `src/api/__init__.py` to register `/api/v1` and `/api/v2` blueprints
  - [x] Ensure legacy endpoints remain available under `/api/v1`
  - [x] Add new blueprint scaffolding for `/api/v2`
- [x] Phase 3 — Operation Mode & State v2 Endpoints
  - [x] Create `src/services/operation_service.py` to wrap Modbus mode/state operations
  - [x] Update `src/api/operation.py` legacy handlers to call the new service
  - [x] Implement `/api/v2/operation/mode` and `/api/v2/operation/state` handlers returning readable strings
  - [x] Support string and integer inputs in v2 POST endpoints with proper validation
- [x] Phase 4 — Extended Alignment & Documentation
  - [x] Outline v2 response structure adjustments in `src/api/zones.py` comments/docstrings
  - [x] Update `API_DOCS.md` with `/api/v2` endpoints and readable payload examples
  - [x] Document snake_case ↔ camelCase mapping rules for mode/state fields
- [x] Phase 5 — Testing Strategy
  - [x] Add `tests/unit/test_state_converter.py` covering valid/invalid mappings
  - [x] Add `tests/integration/test_operation_endpoints.py` for v1/v2 GET and POST flows
  - [x] Mock Modbus context interactions to validate write calls in tests

